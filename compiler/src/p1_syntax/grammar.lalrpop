use { super::*, std::str::FromStr };

grammar;

match {
    // Comments
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    // Regex
    r"[a-zA-Z_]\w*" => IDENTIFIER,
    r"[+-]?\d+" => INTEGER,
    r#""(\\.|[^"\\])*""# => STRING,

    // Keywords
    "func", "external", "type",

    // Groups
    "(", ")",
    "{", "}",

    // Punctuation
    ",", "->", "=",
    ":", ";", "@",
} else {
    // Whitespace
    r"\s*" => { },
}

#[inline]
Boxed<T>: Box<T> = T => Box::new(<>);

#[inline]
List<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub File: File = <items: Item*> => File { <> };

Item: Item = {
    ExternalItem => Item::External(<>),
    TyItem => Item::Ty(<>),
    FuncItem => Item::Func(<>),
};

Identifier: String = IDENTIFIER => <>.to_string();
String: String = STRING => <>.to_string();

Attribute: Attribute = "@" <name: Identifier> "(" <arguments: List<String, ",">> ")" => Attribute { <> };

ExternalItem: ExternalItem = <attributes: Attribute*> "external" "(" <protocol: String> ")" "{" <items: (<Item> ";")*> "}" ";" => ExternalItem { <> };

TyItem: TyItem = <attributes: Attribute*> "type" <name: Identifier> ";" => TyItem { <> };

FuncItem: FuncItem = <attributes: Attribute*> "func" <name: Identifier> "(" <parameters: List<Parameter, ",">> ")" "->" <return_ty: Identifier> <body: ("{" <List<Expression, ";">> "}")?> ";" => FuncItem { <> };

Parameter: Parameter = <name: Identifier> ":" <ty: Identifier> => Parameter { <> };

Integer: u8 = INTEGER => u8::from_str(<>).unwrap();

Expression: Expression = {
    Integer => Expression::Integer(<>),
    <leading: Boxed<Expression>?> <name: Identifier> "(" <arguments: List<Expression, ",">> ")" => Expression::Call { <> },
};
