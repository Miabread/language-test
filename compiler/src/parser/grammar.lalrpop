use {std::str::FromStr, super::*};

grammar;

match {
    // Comments
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    "func", "->",

    "(", ")", "{", "}", // Parens

    // Regex Tokens
    r"[a-zA-Z_]\w*" => IDENTIFIER,
    r"[+-]?\d+" => INT_LITERAL,
} else {
    r"\s*" => { }, // Whitespace
}

#[inline]
Boxed<T>: Box<T> = T => Box::new(<>);

#[inline]
List<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

#[inline]
Identifier: String = IDENTIFIER => <>.to_owned();

pub File: File = <items: Item*> => File { <> };

Item: Item = {
    Function => Item::Function(<>),
}

Function: Function = <signature: FunctionSignature>"{" <body: Expression> "}" => Function { <> };

FunctionSignature: FunctionSignature = "func" <name: Identifier> "(" ")" "->" <return_ty: Identifier> => FunctionSignature { <> };

Expression: Expression = {
    Literal => Expression::Literal(<>),
}

Literal: i32 = INT_LITERAL => i32::from_str(<>).unwrap();
