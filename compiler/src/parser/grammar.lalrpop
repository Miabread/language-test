use {std::str::FromStr, super::*};

grammar;

match {
    // Comments
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    "func", "import", "external", "type", // Keywords

    "->", ";", // Symbols

    "(", ")", "{", "}", // Parens

    // Regex Tokens
    r"[a-zA-Z_]\w*" => IDENTIFIER,
    r"[+-]?\d+" => INT_LITERAL,
    r"[+-]?\d+\.\d+" => FLOAT_LITERAL,
    r#""(\\.|[^"\\])*""# => STRING_LITERAL,
} else {
    r"\s*" => { }, // Whitespace
}

#[inline]
Boxed<T>: Box<T> = T => Box::new(<>);

#[inline]
List<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

#[inline]
Identifier: String = IDENTIFIER => <>.to_owned();

pub File: File = <items: Item*> => File { <> };

Item: Item = {
    Function => Item::Function(<>),
    ImportExtern => Item::ImportExtern(<>),
}

Function: Function = <signature: FunctionSignature>"{" <body: Expression> "}" => Function { <> };

FunctionSignature: FunctionSignature = "func" <name: Identifier> "(" ")" "->" <return_ty: Identifier> => FunctionSignature { <> };

Expression: Expression = {
    Literal => Expression::Literal(<>),
}

Literal: Literal = {
    INT_LITERAL => Literal::Integer(i32::from_str(<>).unwrap()),
    FLOAT_LITERAL => Literal::Float(f32::from_str(<>).unwrap()),
}

StringLiteral: String = STRING_LITERAL => <>[1..(<>.len()-1)].to_owned();

ImportExtern: ImportExtern = "import" "external" "(" <protocol: StringLiteral> ")" "{" <items: ExternItem*> "}" => ImportExtern { <> };

ExternItem: ExternItem = {
    <FunctionSignature> ";" => ExternItem::Function(<>),
    "type" <Identifier> ";" => ExternItem::Type(<>),
}
