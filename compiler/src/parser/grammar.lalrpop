use {std::str::FromStr, super::*};

grammar;

match {
    // Comments
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    "func", "->",

    "(", ")", "{", "}", // Parens

    // Regex Tokens
    r"[a-zA-Z_]\w*" => IDENTIFIER,
    r"[+-]?\d+" => INT_LITERAL,
} else {
    r"\s*" => { }, // Whitespace
}

#[inline]
Boxed<T>: Box<T> = T => Box::new(<>);

#[inline]
List<T, S>: Vec<T> = {
    <v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Function: Function = "func" <name: Identifier> "(" ")" "->" <ty: Identifier> "{" <body: Literal> "}" => Function { <> };

Identifier: String = IDENTIFIER => <>.to_owned();

Literal: i32 = INT_LITERAL => i32::from_str(<>).unwrap();
